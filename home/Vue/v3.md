# Vue3新特性

## 生命周期

``` js
// 新增了 setup 生命周期函数，调用时机在 beforeCreate 和 created 之间。
// 只有卸载的生命周期的改变了名称，其他的没有变。
beforeCreate
 ---> setup 
created 

beforeMount ---> beforeMount
mounted ---> mounted

beforeUpdate ---> beforeUpdate
updated ---> updated

beforeDestroy ---> beforeUnmount
destroyed ---> unmounted


// 注意点：在 setup 函数中导入生命周期函数需一致加 on 前缀。
// 并在 setup 中不能导入 beforeCreate 和 created 函数，因为 setup 相当于他们两个函数了。
// setup 导入生命函数实例
beforeMount ---> onBeforeMount 
mounted ---> onMounted

beforeUpdate ---> onBeforeUpdate
updated ---> onUpdated

beforeUnMount ---> onBeforeUnmount
unmounted ---> onUnmounted

```



## v-model 指令

``` js
// 2.x
<input v-model="msg" placeholder="请输入内容" />
// 底层实现。
<input value={value} @input="value = $event.target.value" placeholder="请输入内容">

<script>
// 在 2.0 中 可以通过 model 配置项来改变 value 绑定的值, 默认值是 value
export default {
    model: {
        value: 'value',
        event: 'input'
    },
    props: {
        value: String
    }
}
</script>

// 3.x
<input v-model:text="value" placeholder="请输入内容" />
// 底层实现。
<input text={value} @update:text="text = $event.target.value" placeholder="请输入内容" />

<script>
// 在 3.0 值移除了 model 配置项，如需更改在 v-model 后面传递要修改的 prop 名。
export default {
    props: {
        text: String
    }
}
</script>

// 注意点：在 3.x 中 .sync 移除了。合并到 v-model冒号绑定的值一起了。
```
[参考链接](https://juejin.cn/post/6970210247726071845)

## ref 
3.x 中创建基本类型数据为响应式函数。

``` js

<template>
    <div>{{ count }}</div>
</template>

<script lang="ts">
import { ref } from 'vue'
export default {
    setup() {
        // 通过 ref 创建的数据，返回的格式是 { value: 0 }。
        // 在 setup 中使用中需通过 .value 形式使用。模板中使用 count 不用 .value 形式，vue 会帮我们 .value。
        const count = ref(0) 
        // 修改了 count 的值，页面使用到时，自动改变 count。
        count.value = 333 

        return {
            count
        }
    }
}
</script>

// 注意点：ref 也可以接受对象或者数组参数，返回格式就是 { value: 对象或数组 }。
```

## reactive 
3.x 中创建对象或者数组响应式数据函数

```js
<template>
 <div class="list">
    <div v-for="(item, index) in countData" :key="index">{{ item }}</div>
 </div>
</template>

<script lang="ts">
import { reactive } from 'vue'
export default {
    setup() {
      // 通过 reactive 创建的数据，返回的格式就是传过来的格式。
      // 在使用中不需要 .value 形式。 
      const countData = reactive({
          list: []
      })

      countData.list = [{a: 1, b: 2, c: 3}]

      return {
          countData
      }
    }
}
</script>
// 注意点：ref 创建的数据本质上还是通过 reactive 函数包裹然后再 value 中接受传过来的参数。
//        reactive 返回的数据，如果直接赋值一个新的数据，会失去响应式。
//        如：const countData = reactive([]) countData = []

``` 

## 响应式
在 2.x 中 vue 实现的响应式是通过 Object.defineProtry 函数来劫持 data 中数据的获取和改变，并在其中订阅依赖和发布依赖来触发页面上数据的改变。但这个函数本身也有缺陷，不能监听新增的数据和以索引方式改变数组的数据，只有通过 $set 和 set来改变数据。

在 3.x 中 vue 就更改了劫持函数，通过 new Proxy 函数来劫持。这个函数就很好的能监听新增的数据和以索引方式改变数组数据。并且他还要更多的方法如：apply 等来监听数据。但他本身是 ES6 才出现的，所以在 IE 浏览器不是兼容的。