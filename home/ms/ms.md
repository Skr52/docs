### 前端面试题

## JS面试题
### JS事件循环机制
`JS` 执行代码分成 同步 和 异步，同步的进到主线程立即执行，异步的会进到任务队列，当主线程的任务执行完毕后，会去任务队列读取对应的任务，推入到主线程执行，
依次执行这个过程，叫做事件循环。

任务队列分成 宏任务 和 微任务。进到任务队列先回检测是否有微任务，有就执行微任务，在执行宏任务。

* 宏任务：script(整体代码)、setTimeout、setInterval、UI 交互事件。
* 微任务：Promise、MutaionObserver、process.nextTick(Node.js 环境)。

### 箭头函数和普通函数的区别

`this` 指向问题

箭头函数的 this 永远指向上下文的this, 也就是取自外层代码块的 this, `bind call apply` 方法改变不了 this 指向。

普通函数的 this 指向调用他的对象

箭头函数中的 this 是定义时取决的，不是使用时取决的。    
## Vue面试题

### Vue组件通讯方式有哪些
* `props`: 子组件通过传参给父组件，父组件通过props定义参数接受，完成组件通讯

* `$emit`: 父组件通过 `$emit` 自定义事件，在自定义事件中传参，子组件通过 `$on` 定义父组件事件，通过事件接受父组件参数。

* `Event Bus` 每一个 `Vue` 实例都是 `Event Bus`, 都支持 `$on/$emit`, 为兄弟组件实例之间创建一个 `new Vue`实例，作为 `Event Bus` 通讯

* `Vuex`: 通过全局状态数据管理仓库，实现各个组件数据共享。

### v-if和v-show的区别

#### 渲染机制不同
* `v-show` 通过display:none来进行元素的显示和隐藏。
* `v-if`  通过创建和销毁元素来进行元素的显示和隐藏。

#### 使用场景
* `v-show` 多用于切换元素显示和隐藏频繁的场景，比如tab切换。
* `v-if` 用于切换元素显示和隐藏少的场景，主要是减少性能的消耗。

### Vuex是什么? 怎么使用? 哪些功能场景使用它?
* `Vuex` 是一个全局状态数据管理仓库, 实现各个组件数据的共享。

### Vuex 分别有 5 种属性

* `state` 主要是存放共享数据的，里面的数据都是响应式的，不可以直接修改里面数据。

* `mutation` 通过定义的方法，同步更改 `state` 状态和数据

* `getters` 可以对 `state` 进行计算操作，类似于`computed`

* `action` 将 `mutation` 里面处理数据的方法变成异步操作。

* `module` 可以让每一个模块拥有自己的`state`、`mutation`、`action`、`getters`,使得结构非常清晰，方便管理

### 使用Vuex的好处?
1. 多层嵌套的组件、兄弟组件间的状态会更好管理维护

2. 缓存一些当前要使用请求远程或本地的数据集（刷新后会自己销毁）

3. 有了第二条，就可以减少向服务器的请求，节省资源。如果你的用户足够多，那么每多出一个请求，对公司来说，都是一大笔钱。

4. 对开发者来说，如果你的项目足够复杂，团队的规模也不仅是一个人，数据集中处理更利于程序的稳定和维护

### 常用的指令有哪些？

* `v-model` 用于表单的输入，实现表单控件和数据的双向绑定

* `v-on` 用于给元素绑定事件

* `v-bind` 用于给元素绑定自定义属性

* `v-if` 用于元素的显示和隐藏

* `v-show` 用于元素的显示和隐藏

* `v-html` 将代用HTML格式的字符串渲染成HTML元素。

* `v-for` 用于源数据多次循环渲染元素或模板块

### 请说下你对生命周期的理解
* Vue的生命周期分成四个阶段：创建阶段、渲染阶段、更新阶段、销毁阶段。

#### 创建阶段触发钩子函数

* `beforeCreate` 初始化 `Vue` 实例前，在当前阶段`data`、`methods`、`watch`、`computed`等数据和方法都不能访问。

* `created` 初始化 `Vue` 实例后，当前阶段完成了数据观测，可以使用数据，更改数据，可以做一些初始数据的获取。更改数据不会触发 `updated` 函数

#### 渲染阶段触发钩子函数

* `beforeMount` 挂载 `DOM` 元素前，`template` 模板已经导入渲染函数编译，`虚拟DOM` 创建完成，即将开始渲染。此时更改数据，不会触发 `updated` 函数。

* `mounted` 挂载 `DOM` 元素完成后，真正`DOM` 元素挂载完成，数据完成双向绑定，可以访问、操作 `DOM` 节点。

#### 更新阶段触发钩子函数

* `beforeUpdate` 在数据更新、虚拟 `DOM` 重新渲染之前触发。

* `updated` 在数据更新、`DOM` 完成更新后。注意点：避免在此阶段更改数据，因为这可能会导致无限循环渲染的更新。

#### 销毁阶段触发钩子函数

* `beforeDestroy` Vue实例销毁前，实例仍然可以使用。一般做清除定时器工作。

* `destroyed` Vue实例销毁后，这个时候 `DOM` 只剩下空壳，数据绑定被卸除，监听被移除，子实例也统统被销毁。

### computed 于 watch 的区别

* `computed` 支持缓存，只有依赖数据发生变化，才会重新进行计算。如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed。

* `watch` 主要提供监听功能，当监听的属性发送变化时，会立即执行该函数。 当一个属性发生变化时，需要执行对应的操作；一对多。

### Vue组件的 `data` 为什么必须是一个函数
* 如果`data`是一个函数的话，这样每复用一次组件，就会返回一份新的`data`，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份`data`，就会造成一个变了全都会变的结果。

* 实例化出来的根组件只有一个, 你可以将它写成对象,或者是返回一个对象的函数。

### Vue2.x和Vue3.x有什么区别

#### 1. 重构响应式系统，使用 `Proxy` 替换 `Object.defineProperty`。  

##### 使用 `Proxy` 优势

* 可以监听到数组类型的变化

* 监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升

* 可拦截 `apply`、`ownKeys`、`has`等13种方法，而`Object.defineProperty`不行

* 直接实现对象属性的新增/删除

#### 2. 新增Composition API，更好的逻辑复用和代码组织

#### 3. 重构 Virtual DOM
* 模板编译时的优化，将一些静态节点编译成常量

* `slot`优化，将`slot`编译为lazy函数，将`slot`的渲染的决定权交给子组件

* 模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）

#### 4. 代码结构调整，更便于Tree shaking，使得体积更小

#### 5. 使用Typescript替换Flow